# Description: This file contains the functions that implement the backward iteration
# algorithm. The algorithm starts from the steady state at time period T and iterates
# backwards to time period 1. The function returns, for each heterogeneous variable,
# the sequence of T-1 disaggregated policy matrices used in the forward iteration.


"""
    BackwardIteration(xVec_endog, exog_paths::NamedTuple,
                      model::SequenceModel, ss_end) -> NamedTuple

Performs the Backward Iteration algorithm for all `:heterogeneous` variables.

## Arguments

- `xVec_endog`: flat vector of length `n_endog × (T-1)` containing the
  endogenous variable sequence. Reshaped internally to `(n_endog × T-1)` where
  column `t` = endogenous values at transition period `t ∈ {1,…,T-1}`.
- `exog_paths`: NamedTuple mapping each `:exogenous` variable name to a
  length-(T-1) vector of values (generated by `generate_exog_paths`).
- `model`: the `SequenceModel`.
- `ss_end`: steady-state solution at `t = T` (the ending steady state). Must
  expose `.policies[varname]` (terminal policy matrix) and `.vars` (NamedTuple
  of all aggregate SS values used as a placeholder for heterogeneous rows).

## Algorithm

For each `:heterogeneous` variable `varname`:
1. Initialise `policies[T]` from `ss_end.policies[varname]`.
2. Iterate backward from `t = T-1` to `t = 1`, calling
   `var.backward_fn(xVals_t, policies[t+1], model)` to get `policies[t]`.
3. `xVals_t` is assembled as a length-`n_v` vector:
   - `:endogenous` rows — from `xVec_endog` at time `t`
   - `:exogenous` rows  — from `exog_paths[key][t]`
   - `:heterogeneous` rows — from `ss_end.vars[key]` (the ending SS aggregate
     value; backward functions typically do not depend on this, but a concrete
     value is required to satisfy the function signature)

## Returns

`NamedTuple` mapping each heterogeneous variable name to a `Vector{Matrix}` of
length T-1, e.g. `(KD = [mat_1, mat_2, …, mat_{T-1}],)`.

## AD compatibility

When `xVec_endog` carries `ForwardDiff.Dual` element types (e.g. during JVP
computation), `policies` is promoted to `Matrix{Dual}` from the first backward
step. The ending SS policy `ss_end.policies[varname]` (Float64) is converted to
`Matrix{TF}` with zero partials so derivatives flow only through the endogenous
sequence. Note: AD compatibility of the specific `backward_fn` implementation
(e.g. `backward_capital`) depends on its own internals and may require further
work (see TODO.md).
"""
function BackwardIteration(xVec_endog,
                           exog_paths::NamedTuple,
                           model::SequenceModel,
                           ss_end)
    @unpack T, n_v, n_endog = model.compspec
    TF = eltype(xVec_endog)

    # Reshape endogenous sequence: n_endog × (T-1), column t = period t values
    xMat_endog = reshape(xVec_endog, n_endog, T - 1)

    all_keys   = var_names(model)
    endog_keys = vars_of_type(model, :endogenous)
    het_keys   = vars_of_type(model, :heterogeneous)
    exog_keys  = vars_of_type(model, :exogenous)

    # Precompute row indices (avoid repeated findfirst inside the hot loop)
    endog_rows = [findfirst(==(k), all_keys) for k in endog_keys]
    exog_rows  = [findfirst(==(k), all_keys) for k in exog_keys]
    het_rows   = [findfirst(==(k), all_keys) for k in het_keys]

    # Pre-fetch ending SS values for heterogeneous variables (Float64 constants)
    het_ss_vals = [ss_end.vars[k] for k in het_keys]

    # Build the full xVals vector at transition period t (1-indexed, t ∈ 1:T-1)
    function get_xvals_at_t(t::Int)
        xVals = Vector{TF}(undef, n_v)
        for (j, row) in enumerate(endog_rows)
            xVals[row] = xMat_endog[j, t]
        end
        for (j, row) in enumerate(exog_rows)
            xVals[row] = exog_paths[exog_keys[j]][t]
        end
        # Heterogeneous vars: backward_fn does not use them; fill with ending SS
        for (j, row) in enumerate(het_rows)
            xVals[row] = het_ss_vals[j]   # Float64 → TF (zero partials)
        end
        return xVals
    end

    # Run backward iteration for each heterogeneous variable
    seqs = map(het_keys) do varname
        var       = model.variables[varname]
        ss_policy = ss_end.policies[varname]   # Matrix{Float64}

        # Allocate T slots; index t ∈ 1:T corresponds to period t
        # policies[T] = ending SS (terminal condition); fill rest backward
        policies    = Vector{Matrix{TF}}(undef, T)
        policies[T] = Matrix{TF}(ss_policy)   # convert Float64 → TF (zero partials)

        for i in 1:T-1
            t = T - i
            policies[t] = var.backward_fn(get_xvals_at_t(t), policies[t + 1], model)
        end

        return policies[1:T-1]
    end

    return NamedTuple{het_keys}(seqs)
end


# ─────────────────────────────────────────────────────────────────────────────
# Development / testing utility (retained for debugging)
# ─────────────────────────────────────────────────────────────────────────────

function FD_LI()
    x = rand(10)
    sort!(x)
    y = x .+ 1.0

    function inter(a)
        linpolate = extrapolate(interpolate((x,), y, Gridded(Linear())), Flat())
        return linpolate.(a)
    end

    z = x .+ 0.3
    J = jacobian(inter, z)
    return J
end
